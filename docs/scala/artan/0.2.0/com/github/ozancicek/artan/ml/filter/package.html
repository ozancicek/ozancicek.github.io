<!DOCTYPE html >
<html>
        <head>
          <title>filter - com.github.ozancicek.artan.ml.filter</title>
          <meta name="description" content="filter - com.github.ozancicek.artan.ml.filter" />
          <meta name="keywords" content="filter com.github.ozancicek.artan.ml.filter" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../../../../index.html';
            var hash = 'com.github.ozancicek.artan.ml.filter.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img alt="Package" src="../../../../../../lib/package_big.png" />
        <p id="owner"><a href="../../../../../package.html" class="extype" name="com">com</a>.<a href="../../../../package.html" class="extype" name="com.github">github</a>.<a href="../../../package.html" class="extype" name="com.github.ozancicek">ozancicek</a>.<a href="../../package.html" class="extype" name="com.github.ozancicek.artan">artan</a>.<a href="../package.html" class="extype" name="com.github.ozancicek.artan.ml">ml</a></p>
        <h1>filter</h1><span class="permalink">
      <a href="../../../../../../index.html#com.github.ozancicek.artan.ml.filter.package" title="Permalink" target="_top">
        <img src="../../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        
        
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="com.github.ozancicek.artan.ml.filter.CubatureKalmanFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CubatureKalmanFilterextendsKalmanTransformer[com.github.ozancicek.artan.ml.filter.CubatureKalmanStateCompute,com.github.ozancicek.artan.ml.filter.CubatureKalmanStateSpec,com.github.ozancicek.artan.ml.filter.CubatureKalmanFilter]withHasProcessFunctionwithHasMeasurementFunction"></a>
      <a id="CubatureKalmanFilter:CubatureKalmanFilter"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="CubatureKalmanFilter.html"><span class="name">CubatureKalmanFilter</span></a><span class="result"> extends <span class="extype" name="com.github.ozancicek.artan.ml.filter.KalmanTransformer">KalmanTransformer</span>[<span class="extype" name="com.github.ozancicek.artan.ml.filter.CubatureKalmanStateCompute">CubatureKalmanStateCompute</span>, <span class="extype" name="com.github.ozancicek.artan.ml.filter.CubatureKalmanStateSpec">CubatureKalmanStateSpec</span>, <a href="CubatureKalmanFilter.html" class="extype" name="com.github.ozancicek.artan.ml.filter.CubatureKalmanFilter">CubatureKalmanFilter</a>] with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasProcessFunction">HasProcessFunction</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasMeasurementFunction">HasMeasurementFunction</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../../index.html#com.github.ozancicek.artan.ml.filter.package@CubatureKalmanFilterextendsKalmanTransformer[com.github.ozancicek.artan.ml.filter.CubatureKalmanStateCompute,com.github.ozancicek.artan.ml.filter.CubatureKalmanStateSpec,com.github.ozancicek.artan.ml.filter.CubatureKalmanFilter]withHasProcessFunctionwithHasMeasurementFunction" title="Permalink" target="_top">
        <img src="../../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Cubature Kalman Filter (CKF), implemented with a stateful spark Transformer for running parallel filters /w spark
dataframes.</p><div class="fullcomment"><div class="comment cmt"><p>Cubature Kalman Filter (CKF), implemented with a stateful spark Transformer for running parallel filters /w spark
dataframes. Transforms an input dataframe of noisy measurements to dataframe of state estimates using stateful
spark transformations, which can be used in both streaming and batch applications. CKF is similar to UKF,
it could be seen as a special case of UKF with good parameters for most general problems.</p><p>In addition to Linear Kalman Filter parameters, following functions
can be specified assuming a state (x_k) with size n_s, and measurements (z_k) with size n_m;</p><p>- f(x_k, F_k), process function for state transition. x_k is state vector and F_k is process model.
  Should output a vector with size (n_s)</p><p>- h(x_k, H_k), measurement function. Should output a vector with size (n_m)</p><p>CKF will predict &amp; estimate the state according to following equations;</p><p>State prediction:
 x_k = f(x_k-1, F_k) + B_k * u_k + w_k</p><p>Measurement incorporation:
 z_k = h(x_k, H_k) + v_k</p><p>Where v_k and w_k are noise vectors drawn from zero mean, Q_k and R_k covariance
distributions.</p><p>The default values of system matrices will not give you a functioning filter, but they will be initialized
with reasonable values given the state and measurement sizes. All of the inputs to the filter can
be specified with a dataframe column which will allow you to have different value across measurements/filters,
or you can specify a constant value across all measurements/filters.
</p></div></div>
    </li><li name="com.github.ozancicek.artan.ml.filter.ExtendedKalmanFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ExtendedKalmanFilterextendsKalmanTransformer[com.github.ozancicek.artan.ml.filter.ExtendedKalmanStateCompute,com.github.ozancicek.artan.ml.filter.ExtendedKalmanStateSpec,com.github.ozancicek.artan.ml.filter.ExtendedKalmanFilter]withHasProcessFunctionwithHasProcessStateJacobianwithHasProcessNoiseJacobianwithHasMeasurementFunctionwithHasMeasurementStateJacobianwithHasMeasurementNoiseJacobian"></a>
      <a id="ExtendedKalmanFilter:ExtendedKalmanFilter"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ExtendedKalmanFilter.html"><span class="name">ExtendedKalmanFilter</span></a><span class="result"> extends <span class="extype" name="com.github.ozancicek.artan.ml.filter.KalmanTransformer">KalmanTransformer</span>[<span class="extype" name="com.github.ozancicek.artan.ml.filter.ExtendedKalmanStateCompute">ExtendedKalmanStateCompute</span>, <span class="extype" name="com.github.ozancicek.artan.ml.filter.ExtendedKalmanStateSpec">ExtendedKalmanStateSpec</span>, <a href="ExtendedKalmanFilter.html" class="extype" name="com.github.ozancicek.artan.ml.filter.ExtendedKalmanFilter">ExtendedKalmanFilter</a>] with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasProcessFunction">HasProcessFunction</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasProcessStateJacobian">HasProcessStateJacobian</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasProcessNoiseJacobian">HasProcessNoiseJacobian</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasMeasurementFunction">HasMeasurementFunction</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasMeasurementStateJacobian">HasMeasurementStateJacobian</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasMeasurementNoiseJacobian">HasMeasurementNoiseJacobian</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../../index.html#com.github.ozancicek.artan.ml.filter.package@ExtendedKalmanFilterextendsKalmanTransformer[com.github.ozancicek.artan.ml.filter.ExtendedKalmanStateCompute,com.github.ozancicek.artan.ml.filter.ExtendedKalmanStateSpec,com.github.ozancicek.artan.ml.filter.ExtendedKalmanFilter]withHasProcessFunctionwithHasProcessStateJacobianwithHasProcessNoiseJacobianwithHasMeasurementFunctionwithHasMeasurementStateJacobianwithHasMeasurementNoiseJacobian" title="Permalink" target="_top">
        <img src="../../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Extended Kalman Filter (EKF), implemented with a stateful spark Transformer for running parallel filters /w spark
dataframes.</p><div class="fullcomment"><div class="comment cmt"><p>Extended Kalman Filter (EKF), implemented with a stateful spark Transformer for running parallel filters /w spark
dataframes. Transforms an input dataframe of noisy measurements to dataframe of state estimates using stateful
spark transformations, which can be used in both streaming and batch applications.</p><p>Typically for nonlinear systems, it allows either of state transition and observation models to be
differentiable functions instead of matrices. It also allows speciying non-additive noise covariances for
state transition and measurements with noise jacobian matrices depending on state.</p><p>All Linear Kalman Filter parameters are also valid for EKF. In addition to Linear Kalman
Filter parameters,following functions can be specified assuming a state (x_k) with size n_s,
and measurements (z_k) with size n_m;</p><p>- f(x_k, F_k), process function for state transition. x_k is state vector and F_k is process model.
  Should output a vector with size (n_s)</p><p>- f_j(x_k, F_k), process jacobian function for state transition. x_k is state vector and F_k is process model.
  Should output a matrix with dimensions (n_s, n_s)</p><p>- q_j(x_k, Q_k). process noise jacobian function for non-additive noise. x_k is state vector and Q_k is process
  noise matrix with dimensions (n_noise, n_noise). Should output a matrix with dimensions (n_s, n_noise). The result
  of q_j * Q_k * q_j.T transformation should be (n_s, n_s)</p><p>- h(x_k, H_k), measurement function. Should output a vector with size (n_m)</p><p>- hj(x_j, H_k), measurement jacobian function. Should output a matrix with dimensions (n_s, n_m)</p><p>- r_j(x_k, R_k). measurement noise jacobian function for non-additive noise. x_k is state vector and R_k is process
  noise matrix with dimensions (n_noise, n_noise). Should output a matrix with dimensions (n_s, n_noise). The result
  of q_j * Q_k * q_j.T transformation should be (n_s, n_s)</p><p>EKF will predict &amp; estimate the state according to following equations</p><p>State prediction:
 x_k = f(x_k-1, F_k) + B_k * u_k + w_k</p><p>Measurement incorporation:
 z_k = h(x_k, H_k) + v_k</p><p>Where v_k and w_k are noise vectors drawn from zero mean, q_j * Q_k * q_j.T and r_j * R_k *r_j.T covariance
distributions.</p><p>The default values of system matrices will not give you a functioning filter, but they will be initialized
with reasonable values given the state and measurement sizes. All of the inputs to the filter can
be specified with a dataframe column which will allow you to have different value across measurements/filters,
or you can specify a constant value across all measurements/filters.
</p></div></div>
    </li><li name="com.github.ozancicek.artan.ml.filter.LeastMeanSquaresFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="LeastMeanSquaresFilterextendsStatefulTransformer[String,com.github.ozancicek.artan.ml.state.LMSInput,com.github.ozancicek.artan.ml.state.LMSState,com.github.ozancicek.artan.ml.state.LMSOutput,com.github.ozancicek.artan.ml.filter.LeastMeanSquaresFilter]withHasLabelColwithHasFeaturesColwithHasInitialStatewithHasLearningRatewithHasRegularizationConstantwithHasInitialStateCol"></a>
      <a id="LeastMeanSquaresFilter:LeastMeanSquaresFilter"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="LeastMeanSquaresFilter.html"><span class="name">LeastMeanSquaresFilter</span></a><span class="result"> extends <span class="extype" name="com.github.ozancicek.artan.ml.state.StatefulTransformer">StatefulTransformer</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="com.github.ozancicek.artan.ml.state.LMSInput">LMSInput</span>, <span class="extype" name="com.github.ozancicek.artan.ml.state.LMSState">LMSState</span>, <a href="../state/LMSOutput.html" class="extype" name="com.github.ozancicek.artan.ml.state.LMSOutput">LMSOutput</a>, <a href="LeastMeanSquaresFilter.html" class="extype" name="com.github.ozancicek.artan.ml.filter.LeastMeanSquaresFilter">LeastMeanSquaresFilter</a>] with <span class="extype" name="org.apache.spark.ml.param.shared.HasLabelCol">HasLabelCol</span> with <span class="extype" name="org.apache.spark.ml.param.shared.HasFeaturesCol">HasFeaturesCol</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasInitialState">HasInitialState</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasLearningRate">HasLearningRate</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasRegularizationConstant">HasRegularizationConstant</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasInitialStateCol">HasInitialStateCol</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../../index.html#com.github.ozancicek.artan.ml.filter.package@LeastMeanSquaresFilterextendsStatefulTransformer[String,com.github.ozancicek.artan.ml.state.LMSInput,com.github.ozancicek.artan.ml.state.LMSState,com.github.ozancicek.artan.ml.state.LMSOutput,com.github.ozancicek.artan.ml.filter.LeastMeanSquaresFilter]withHasLabelColwithHasFeaturesColwithHasInitialStatewithHasLearningRatewithHasRegularizationConstantwithHasInitialStateCol" title="Permalink" target="_top">
        <img src="../../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Normalized Least Mean Squares filter, implemented with a stateful spark Transformer for running parallel
filters /w spark dataframes.</p><div class="fullcomment"><div class="comment cmt"><p>Normalized Least Mean Squares filter, implemented with a stateful spark Transformer for running parallel
filters /w spark dataframes. Transforms an input dataframe of observations to a dataframe of model parameters
using stateful spark transformations, which can be used in both streaming and batch applications.</p><p>Belonging to stochastic gradient descent type of methods, LMS minimizes SSE on each measurement
based on the expectation of steepest descending gradient.</p><p>Let w denote the model parameter vector, u denote the features vector, and d for label corresponding to u.
Normalized LMS computes w at step k recursively by;</p><p>e = d - u.T * w_k-1
w_k = w_k-1 + m * e * u /(c + u.T*u)</p><p>Where
 m: Learning rate
 c: Regularization constant
</p></div></div>
    </li><li name="com.github.ozancicek.artan.ml.filter.LinearKalmanFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="LinearKalmanFilterextendsKalmanTransformer[com.github.ozancicek.artan.ml.filter.LinearKalmanStateCompute,com.github.ozancicek.artan.ml.filter.LinearKalmanStateSpec,com.github.ozancicek.artan.ml.filter.LinearKalmanFilter]"></a>
      <a id="LinearKalmanFilter:LinearKalmanFilter"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="LinearKalmanFilter.html"><span class="name">LinearKalmanFilter</span></a><span class="result"> extends <span class="extype" name="com.github.ozancicek.artan.ml.filter.KalmanTransformer">KalmanTransformer</span>[<span class="extype" name="com.github.ozancicek.artan.ml.filter.LinearKalmanStateCompute">LinearKalmanStateCompute</span>, <span class="extype" name="com.github.ozancicek.artan.ml.filter.LinearKalmanStateSpec">LinearKalmanStateSpec</span>, <a href="LinearKalmanFilter.html" class="extype" name="com.github.ozancicek.artan.ml.filter.LinearKalmanFilter">LinearKalmanFilter</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../../index.html#com.github.ozancicek.artan.ml.filter.package@LinearKalmanFilterextendsKalmanTransformer[com.github.ozancicek.artan.ml.filter.LinearKalmanStateCompute,com.github.ozancicek.artan.ml.filter.LinearKalmanStateSpec,com.github.ozancicek.artan.ml.filter.LinearKalmanFilter]" title="Permalink" target="_top">
        <img src="../../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Linear Kalman Filter, implemented with a stateful spark Transformer for running parallel filters /w spark
dataframes.</p><div class="fullcomment"><div class="comment cmt"><p>Linear Kalman Filter, implemented with a stateful spark Transformer for running parallel filters /w spark
dataframes. Transforms an input dataframe of noisy measurements to dataframe of state estimates using stateful
spark transformations, which can be used in both streaming and batch applications.</p><p>Assuming a state (x_k) with size n_s, and measurements (z_k) with size n_m, following parameters should be specified;</p><p>- F_k, process model, matrix with dimensions (n_s, n_s)
- H_k, measurement model, matrix with dimensions (n_s, n_m)
- Q_k, process noise covariance, matrix with dimensions (n_s, n_s)
- R_k, measurement noise covariance, matrix with dimensions (n_m, n_m)
- B_k, optional control model, matrix with dimensions (n_s, n_control)
- u_k, optional control vector, vector with size (n_control)</p><p>Linear Kalman Filter will predict &amp; estimate the state according to following equations</p><p>State prediction:
 x_k = F_k * x_k-1 + B_k * u_k + w_k</p><p>Measurement incorporation:
 z_k = H_k * x_k + v_k</p><p>Where v_k and w_k are noise vectors drawn from zero mean, Q_k and R_k covariance distributions.</p><p>The default values of system matrices will not give you a functioning filter, but they will be initialized
with reasonable values given the state and measurement sizes. All of the inputs to the filter can
be specified with a dataframe column which will allow you to have different value across measurements/filters,
or you can specify a constant value across all measurements/filters.
</p></div></div>
    </li><li name="com.github.ozancicek.artan.ml.filter.RecursiveLeastSquaresFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RecursiveLeastSquaresFilterextendsStatefulTransformer[String,com.github.ozancicek.artan.ml.state.RLSInput,com.github.ozancicek.artan.ml.state.RLSState,com.github.ozancicek.artan.ml.state.RLSOutput,com.github.ozancicek.artan.ml.filter.RecursiveLeastSquaresFilter]withHasLabelColwithHasFeaturesColwithHasForgettingFactorwithHasInitialStatewithHasRegularizationMatrixwithHasInitialStateColwithHasRegularizationMatrixCol"></a>
      <a id="RecursiveLeastSquaresFilter:RecursiveLeastSquaresFilter"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="RecursiveLeastSquaresFilter.html"><span class="name">RecursiveLeastSquaresFilter</span></a><span class="result"> extends <span class="extype" name="com.github.ozancicek.artan.ml.state.StatefulTransformer">StatefulTransformer</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="com.github.ozancicek.artan.ml.state.RLSInput">RLSInput</span>, <span class="extype" name="com.github.ozancicek.artan.ml.state.RLSState">RLSState</span>, <a href="../state/RLSOutput.html" class="extype" name="com.github.ozancicek.artan.ml.state.RLSOutput">RLSOutput</a>, <a href="RecursiveLeastSquaresFilter.html" class="extype" name="com.github.ozancicek.artan.ml.filter.RecursiveLeastSquaresFilter">RecursiveLeastSquaresFilter</a>] with <span class="extype" name="org.apache.spark.ml.param.shared.HasLabelCol">HasLabelCol</span> with <span class="extype" name="org.apache.spark.ml.param.shared.HasFeaturesCol">HasFeaturesCol</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasForgettingFactor">HasForgettingFactor</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasInitialState">HasInitialState</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasRegularizationMatrix">HasRegularizationMatrix</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasInitialStateCol">HasInitialStateCol</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasRegularizationMatrixCol">HasRegularizationMatrixCol</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../../index.html#com.github.ozancicek.artan.ml.filter.package@RecursiveLeastSquaresFilterextendsStatefulTransformer[String,com.github.ozancicek.artan.ml.state.RLSInput,com.github.ozancicek.artan.ml.state.RLSState,com.github.ozancicek.artan.ml.state.RLSOutput,com.github.ozancicek.artan.ml.filter.RecursiveLeastSquaresFilter]withHasLabelColwithHasFeaturesColwithHasForgettingFactorwithHasInitialStatewithHasRegularizationMatrixwithHasInitialStateColwithHasRegularizationMatrixCol" title="Permalink" target="_top">
        <img src="../../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Recursive formulation of least squares with exponential weighting &amp; regularization, implemented with
a stateful spark Transformer for running parallel filters /w spark dataframes.</p><div class="fullcomment"><div class="comment cmt"><p>Recursive formulation of least squares with exponential weighting &amp; regularization, implemented with
a stateful spark Transformer for running parallel filters /w spark dataframes. Transforms an input dataframe
of observations to a dataframe of model parameters using stateful spark transformations, which can be used
in both streaming and batch applications.</p><p>Let w denote the model parameters and w_est denote our prior belief. RLS minimizes following regularization
&amp; weighted SSE terms;</p><p>(w - w_est).T * (lambda<sup>(-N-1) * P)</sup>(-1) * (w - w_est) + Sum(lambda(N - j)*(d_k - u_k.T * w),  k = 0,1, .. N)</p><p>Where:</p><ul><li>lambda: forgetting factor, or exponential weighting factor. Between 0 and 1.</li><li>P: regularization matrix. Smaller values increseas the weight of regularization term, whereas larger values
   increases the weight of weighted SSE term.</li><li>d_k, u_k: label and features vector at time step k.
</li></ul></div></div>
    </li><li name="com.github.ozancicek.artan.ml.filter.UnscentedKalmanFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="UnscentedKalmanFilterextendsKalmanTransformer[com.github.ozancicek.artan.ml.filter.UnscentedKalmanStateCompute,com.github.ozancicek.artan.ml.filter.UnscentedKalmanStateSpec,com.github.ozancicek.artan.ml.filter.UnscentedKalmanFilter]withHasProcessFunctionwithHasMeasurementFunctionwithAdaptiveNoiseParamswithSigmaPointsParams"></a>
      <a id="UnscentedKalmanFilter:UnscentedKalmanFilter"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="UnscentedKalmanFilter.html"><span class="name">UnscentedKalmanFilter</span></a><span class="result"> extends <span class="extype" name="com.github.ozancicek.artan.ml.filter.KalmanTransformer">KalmanTransformer</span>[<span class="extype" name="com.github.ozancicek.artan.ml.filter.UnscentedKalmanStateCompute">UnscentedKalmanStateCompute</span>, <span class="extype" name="com.github.ozancicek.artan.ml.filter.UnscentedKalmanStateSpec">UnscentedKalmanStateSpec</span>, <a href="UnscentedKalmanFilter.html" class="extype" name="com.github.ozancicek.artan.ml.filter.UnscentedKalmanFilter">UnscentedKalmanFilter</a>] with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasProcessFunction">HasProcessFunction</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.HasMeasurementFunction">HasMeasurementFunction</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.AdaptiveNoiseParams">AdaptiveNoiseParams</span> with <span class="extype" name="com.github.ozancicek.artan.ml.filter.SigmaPointsParams">SigmaPointsParams</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../../index.html#com.github.ozancicek.artan.ml.filter.package@UnscentedKalmanFilterextendsKalmanTransformer[com.github.ozancicek.artan.ml.filter.UnscentedKalmanStateCompute,com.github.ozancicek.artan.ml.filter.UnscentedKalmanStateSpec,com.github.ozancicek.artan.ml.filter.UnscentedKalmanFilter]withHasProcessFunctionwithHasMeasurementFunctionwithAdaptiveNoiseParamswithSigmaPointsParams" title="Permalink" target="_top">
        <img src="../../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Unscented Kalman Filter (UKF), implemented with a stateful spark Transformer for running parallel filters /w spark
dataframes.</p><div class="fullcomment"><div class="comment cmt"><p>Unscented Kalman Filter (UKF), implemented with a stateful spark Transformer for running parallel filters /w spark
dataframes. Transforms an input dataframe of noisy measurements to dataframe of state estimates using stateful
spark transformations, which can be used in both streaming and batch applications.</p><p>Similar to Extended Kalman Filter (EKF), UKF is aimed for filtering nonlinear systems. With deterministic sampling
techniques, it picks up a minimal sample points and propogates them through state transition and measurement
functions. It doesn't need specifying jacobian functions. Instead, sampling algorithms with their hyperparameters
can be selected from available implementations. All linear kalman filter parameters are also valid
for UKF. In addition to Linear Kalman Filter parameters, following functions
can be specified assuming a state (x_k) with size n_s, and measurements (z_k) with size n_m;</p><p>- f(x_k, F_k), process function for state transition. x_k is state vector and F_k is process model.
  Should output a vector with size (n_s)</p><p>- h(x_k, H_k), measurement function. Should output a vector with size (n_m)</p><p>UKF will predict &amp; estimate the state according to following equations;</p><p>State prediction:
 x_k = f(x_k-1, F_k) + B_k * u_k + w_k</p><p>Measurement incorporation:
 z_k = h(x_k, H_k) + v_k</p><p>Where v_k and w_k are noise vectors drawn from zero mean, Q_k and R_k covariance
distributions.</p><p>The default values of system matrices will not give you a functioning filter, but they will be initialized
with reasonable values given the state and measurement sizes. All of the inputs to the filter can
be specified with a dataframe column which will allow you to have different value across measurements/filters,
or you can specify a constant value across all measurements/filters.
</p></div></div>
    </li></ol>
            </div>

        

        

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Members</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
